//
//  DomainTests-DomainMocks.generated.swift
//  Domain
//
//  Generated by Mockingbird v0.16.0.
//  DO NOT EDIT
//

@testable import Domain
@testable import Mockingbird
import Foundation
import Swift

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AuthUser

public final class AuthUserMock: Domain.AuthUser, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "Domain"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`userId`: String, `password`: String, `roles`: Array<Domain.Role>, __file: StaticString = #file, __line: UInt = #line) throws -> AuthUserMock { fatalError("See 'Thunk Pruning' in the README") }
  }

  // MARK: Mocked `getRoles`()

  public override func `getRoles`() -> Array<Domain.Role> { fatalError("See 'Thunk Pruning' in the README") }

  public func `getRoles`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Array<Domain.Role>, Array<Domain.Role>> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `getPassword`()

  public override func `getPassword`() -> String { fatalError("See 'Thunk Pruning' in the README") }

  public func `getPassword`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> String, String> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `getUserId`()

  public override func `getUserId`() -> String { fatalError("See 'Thunk Pruning' in the README") }

  public func `getUserId`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> String, String> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init(`userId`: String, `password`: String, `roles`: Array<Domain.Role>)

  public required override init(`userId`: String, `password`: String, `roles`: Array<Domain.Role>) throws { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(AuthUser.self).initialize(…)`.
public func mock(_ type: Domain.AuthUser.Type, file: StaticString = #file, line: UInt = #line) -> AuthUserMock.InitializerProxy.Type {
  return AuthUserMock.InitializerProxy.self
}

// MARK: - Mocked PersonRepository

public final class PersonRepositoryMock: Domain.PersonRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "Domain"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return self.stubbingContext.sourceLocation }
    set {
      self.stubbingContext.sourceLocation = newValue
      PersonRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `personExists`(`id`: String)

  public func `personExists`(`id`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`personExists`(`id`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`id`)], returnType: Swift.ObjectIdentifier((Bool).self))
    return self.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Bool {
        return concreteImplementation(`id`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = self.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(self.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `personExists`(`id`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`id`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`personExists`(`id`: String) -> Bool", arguments: arguments, returnType: Swift.ObjectIdentifier((Bool).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `savePerson`(`person`: Domain.Person)

  public func `savePerson`(`person`: Domain.Person) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`savePerson`(`person`: Domain.Person) -> Void", arguments: [Mockingbird.ArgumentMatcher(`person`)], returnType: Swift.ObjectIdentifier((Void).self))
    self.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = self.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Domain.Person) -> Void {
        concreteImplementation(`person`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `savePerson`(`person`: @escaping @autoclosure () -> Domain.Person) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Domain.Person) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`person`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`savePerson`(`person`: Domain.Person) -> Void", arguments: arguments, returnType: Swift.ObjectIdentifier((Void).self))
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Domain.Person) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Returns a concrete mock of `PersonRepository`.
public func mock(_ type: Domain.PersonRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> PersonRepositoryMock {
  return PersonRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked PersonService

public final class PersonServiceMock: Domain.PersonService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "Domain"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`personRepository`: Domain.PersonRepository, __file: StaticString = #file, __line: UInt = #line) -> PersonServiceMock { fatalError("See 'Thunk Pruning' in the README") }
  }

  // MARK: Mocked `savePerson`(`person`: Domain.Person)

  public override func `savePerson`(`person`: Domain.Person) throws -> Void { fatalError("See 'Thunk Pruning' in the README") }

  public func `savePerson`(`person`: @escaping @autoclosure () -> Domain.Person) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Domain.Person) throws -> Void, Void> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init(`personRepository`: Domain.PersonRepository)

  public required override init(`personRepository`: Domain.PersonRepository) { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(PersonService.self).initialize(…)`.
public func mock(_ type: Domain.PersonService.Type, file: StaticString = #file, line: UInt = #line) -> PersonServiceMock.InitializerProxy.Type {
  return PersonServiceMock.InitializerProxy.self
}

// MARK: - Mocked Person

public final class PersonMock: Domain.Person, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "Domain"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`id`: String, `name`: String, `authUser`: Domain.AuthUser, __file: StaticString = #file, __line: UInt = #line) throws -> PersonMock { fatalError("See 'Thunk Pruning' in the README") }
  }

  // MARK: Mocked `getAuthUser`()

  public override func `getAuthUser`() -> Domain.AuthUser { fatalError("See 'Thunk Pruning' in the README") }

  public func `getAuthUser`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Domain.AuthUser, Domain.AuthUser> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `getId`()

  public override func `getId`() -> String { fatalError("See 'Thunk Pruning' in the README") }

  public func `getId`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> String, String> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `getName`()

  public override func `getName`() -> String { fatalError("See 'Thunk Pruning' in the README") }

  public func `getName`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> String, String> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init(`id`: String, `name`: String, `authUser`: Domain.AuthUser)

  public required override init(`id`: String, `name`: String, `authUser`: Domain.AuthUser) throws { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Person.self).initialize(…)`.
public func mock(_ type: Domain.Person.Type, file: StaticString = #file, line: UInt = #line) -> PersonMock.InitializerProxy.Type {
  return PersonMock.InitializerProxy.self
}

// MARK: - Mocked RoleRepository

public final class RoleRepositoryMock: Domain.RoleRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "Domain"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getRoles`()

  public func `getRoles`() -> [Domain.Role] { fatalError("See 'Thunk Pruning' in the README") }

  public func `getRoles`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [Domain.Role], [Domain.Role]> { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns a concrete mock of `RoleRepository`.
public func mock(_ type: Domain.RoleRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> RoleRepositoryMock {
  return RoleRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Role

public final class RoleMock: Domain.Role, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.16.0", "module_name": "Domain"])
  public var sourceLocation: Mockingbird.SourceLocation? { get { fatalError("See 'Thunk Pruning' in the README") } set { fatalError("See 'Thunk Pruning' in the README") } }

  public enum InitializerProxy {
    public static func initialize(`name`: String, __file: StaticString = #file, __line: UInt = #line) -> RoleMock { fatalError("See 'Thunk Pruning' in the README") }
  }

  // MARK: Mocked `getName`()

  public override func `getName`() -> String { fatalError("See 'Thunk Pruning' in the README") }

  public func `getName`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> String, String> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `getDescription`()

  public override func `getDescription`() -> String? { fatalError("See 'Thunk Pruning' in the README") }

  public func `getDescription`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> String?, String?> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked `setDescription`(`description`: String)

  public override func `setDescription`(`description`: String) -> Void { fatalError("See 'Thunk Pruning' in the README") }

  public func `setDescription`(`description`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> Void, Void> { fatalError("See 'Thunk Pruning' in the README") }

  // MARK: Mocked init(`name`: String)

  public required override init(`name`: String) { fatalError("See 'Thunk Pruning' in the README") }
}

/// Returns an abstract mock which should be initialized using `mock(Role.self).initialize(…)`.
public func mock(_ type: Domain.Role.Type, file: StaticString = #file, line: UInt = #line) -> RoleMock.InitializerProxy.Type {
  return RoleMock.InitializerProxy.self
}
